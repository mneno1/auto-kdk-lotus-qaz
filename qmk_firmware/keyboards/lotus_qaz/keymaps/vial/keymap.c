// Generated by Vial Keymap C Editor (https://vial-keymap-c-editor.pages.dev)

#include QMK_KEYBOARD_H

#ifdef QMK_SETTINGS
#include "qmk_settings.h"
#endif

/* USER INCLUDE BEGIN */
#include "quantum.h"
/* USER INCLUDE END */

/* GENERATED CODE BEGIN */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [0] = LAYOUT(
                   KC_Q,            KC_W,            KC_E,            KC_R,
                   KC_T,            KC_Y,            KC_U,            KC_I,
                   KC_O,            KC_P, MT(MOD_LSFT,KC_A),          KC_S,
                   KC_D,            KC_F,            KC_G,            KC_H,
                   KC_J,            KC_K,            KC_L, MT(MOD_RSFT,KC_SEMICOLON),
                   KC_Z,            KC_X,            KC_C,            KC_V,
                   KC_B,      KC_MS_BTN1,      KC_MS_BTN2,            KC_N,
                   KC_M,        KC_COMMA,          KC_DOT,        KC_SLASH,
        MT(MOD_LCTL,KC_LANGUAGE_1),     KC_LEFT_ALT,  LT(4,KC_SPACE), LT(2,KC_DELETE),
        LT(1,KC_BACKSPACE),  LT(3,KC_ENTER),    KC_RIGHT_ALT, MT(MOD_RCTL,KC_LANGUAGE_2)
    ),
    [1] = LAYOUT(
                   KC_1,            KC_2,            KC_3,            KC_4,
                   KC_5,            KC_6,            KC_7,            KC_8,
                   KC_9,            KC_0,           KC_NO,           KC_NO,
         (QK_LSFT|KC_9),  (QK_LSFT|KC_0),           KC_NO,           KC_NO,
        KC_LEFT_BRACKET, KC_RIGHT_BRACKET, (QK_LSFT|KC_BACKSLASH),    KC_BACKSLASH,
                  KC_NO,           KC_NO, (QK_LSFT|KC_LEFT_BRACKET), (QK_LSFT|KC_RIGHT_BRACKET),
                  KC_NO,  KC_TRANSPARENT,  KC_TRANSPARENT,           KC_NO,
                  KC_NO,           KC_NO,           KC_NO,           KC_NO,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT
    ),
    [2] = LAYOUT(
         (QK_LSFT|KC_1),  (QK_LSFT|KC_2),  (QK_LSFT|KC_3),  (QK_LSFT|KC_4),
         (QK_LSFT|KC_5),  (QK_LSFT|KC_6),  (QK_LSFT|KC_7),  (QK_LSFT|KC_8),
               KC_MINUS, (QK_LSFT|KC_MINUS),        KC_GRAVE, (QK_LSFT|KC_GRAVE),
        (QK_LSFT|KC_QUOTE),        KC_QUOTE,           KC_NO,          KC_F11,
                 KC_F12,           KC_NO,        KC_EQUAL, (QK_LSFT|KC_EQUAL),
                  KC_F1,           KC_F2,           KC_F3,           KC_F4,
                  KC_F5,  KC_TRANSPARENT,  KC_TRANSPARENT,           KC_F6,
                  KC_F7,           KC_F8,           KC_F9,          KC_F10,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT
    ),
    [3] = LAYOUT(
        (QK_LCTL|QK_LSFT|KC_TAB), (QK_LCTL|KC_TAB),  (QK_LGUI|KC_E),  (QK_LGUI|KC_R),
         (QK_LCTL|KC_T),           KC_NO,      KC_PAGE_UP,           KC_UP,
           KC_PAGE_DOWN, KC_PRINT_SCREEN,  (QK_LCTL|KC_A),  (QK_LCTL|KC_S),
         (QK_LGUI|KC_D),  (QK_LCTL|KC_F),  (QK_LCTL|KC_G),         KC_HOME,
                KC_LEFT,         KC_DOWN,        KC_RIGHT,          KC_END,
         (QK_LCTL|KC_Z),  (QK_LCTL|KC_X),  (QK_LCTL|KC_C),  (QK_LCTL|KC_V),
         (QK_LCTL|KC_B),  KC_TRANSPARENT,  KC_TRANSPARENT,           KC_NO,
                  KC_NO,           KC_NO,           KC_NO,       KC_INSERT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT
    ),
    [4] = LAYOUT(
                  KC_NO,           KC_NO, (QK_LSFT|QK_LGUI|KC_UP),           KC_NO,
                  KC_NO,           KC_NO,           KC_NO, (QK_LGUI|KC_UP),
                  KC_NO,           KC_NO, (QK_LCTL|QK_LGUI|KC_LEFT), (QK_LSFT|QK_LGUI|KC_LEFT),
        (QK_LSFT|QK_LGUI|KC_DOWN), (QK_LSFT|QK_LGUI|KC_RIGHT), (QK_LCTL|QK_LGUI|KC_RIGHT),           KC_NO,
        (QK_LGUI|KC_LEFT), (QK_LGUI|KC_DOWN), (QK_LGUI|KC_RIGHT),           KC_NO,
                  KC_NO,           KC_NO,           KC_NO,           KC_NO,
                  KC_NO,  KC_TRANSPARENT,  KC_TRANSPARENT,           KC_NO,
                  KC_NO,           KC_NO,           KC_NO,           KC_NO,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT
    ),
    [5] = LAYOUT(
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT
    ),
    [6] = LAYOUT(
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT
    ),
    [7] = LAYOUT(
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
         KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT
    )
};

#if defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
};
#endif

// Tap Dance definitions
#define TAP_DANCE_ENTRY(onTap, onHold, onDoubleTap, onTapHold, tappingTerm) ((vial_tap_dance_entry_t){.on_tap = onTap, .on_hold = onHold, .on_double_tap = onDoubleTap, .on_tap_hold = onTapHold, .custom_tapping_term = tappingTerm})
#if VIAL_TAP_DANCE_ENTRIES > 0
const vial_tap_dance_entry_t default_tap_dance_entries[] = {
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200)
};
#endif

// Combo definitions
#define COMBO_ENTRY(k1, k2, k3, k4, result) ((vial_combo_entry_t){.input ={k1, k2, k3, k4}, .output = result})
#if VIAL_COMBO_ENTRIES > 0
const vial_combo_entry_t PROGMEM default_combo_entries[] = {
    COMBO_ENTRY(KC_D, KC_S, KC_NO, KC_NO, KC_TAB),
    COMBO_ENTRY(KC_Q, KC_W, KC_NO, KC_NO, KC_ESCAPE),
    COMBO_ENTRY(KC_W, KC_E, KC_NO, KC_NO, KC_LEFT_GUI),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO)
};
#endif

// Macro buffer
const uint8_t PROGMEM default_macro_buffer[] = {
    
};

// Key Override definitions
#if VIAL_KEY_OVERRIDE_ENTRIES > 0
const vial_key_override_entry_t default_key_override_entries[] = {
    {
        KC_NO, // trigger key
        KC_NO, // replacement key
        0xffff, // layer mask
        0, // trigger mods
        0, // negative mod mask
        0, // suppressed mods
        0 // options
    },
    {
        KC_NO, // trigger key
        KC_NO, // replacement key
        0xffff, // layer mask
        0, // trigger mods
        0, // negative mod mask
        0, // suppressed mods
        0 // options
    },
    {
        KC_NO, // trigger key
        KC_NO, // replacement key
        0xffff, // layer mask
        0, // trigger mods
        0, // negative mod mask
        0, // suppressed mods
        0 // options
    },
    {
        KC_NO, // trigger key
        KC_NO, // replacement key
        0xffff, // layer mask
        0, // trigger mods
        0, // negative mod mask
        0, // suppressed mods
        0 // options
    }
};
#endif

// Initialize Vial dynamic items
void __real_dynamic_keymap_reset(void);
void __wrap_dynamic_keymap_reset(void) {
    __real_dynamic_keymap_reset();

#if VIAL_TAP_DANCE_ENTRIES > 0
    for (size_t i = 0; i < sizeof(default_tap_dance_entries) / sizeof(default_tap_dance_entries[0]); ++i) {
        dynamic_keymap_set_tap_dance(i, &default_tap_dance_entries[i]);
    }
#endif
#if VIAL_COMBO_ENTRIES > 0
    for (size_t i = 0; i < sizeof(default_combo_entries) / sizeof(default_combo_entries[0]); ++i) {
        dynamic_keymap_set_combo(i, &default_combo_entries[i]);
    }
#endif
#if VIAL_KEY_OVERRIDE_ENTRIES > 0
    for (size_t i = 0; i < sizeof(default_key_override_entries) / sizeof(default_key_override_entries[0]); ++i) {
        dynamic_keymap_set_key_override(i, &default_key_override_entries[i]);
    }
#endif
#ifdef QMK_SETTINGS
    qmk_settings_t qs;
    uint8_t* p_qs = (uint8_t*)&qs;
    for (size_t i = 0; i < sizeof(qs); ++i) {
        p_qs[i] = dynamic_keymap_get_qmk_settings(i);
    }
    #ifdef VIAL_DEFAULT_TAPPING
        qs.tapping = VIAL_DEFAULT_TAPPING;
    #endif
    #ifdef VIAL_DEFAULT_AUTO_SHIFT
        qs.auto_shift = VIAL_DEFAULT_AUTO_SHIFT;
    #endif
    #ifdef DEFAULT_GRAVE_ESC_OVERRIDE
        qs.grave_esc_override = DEFAULT_GRAVE_ESC_OVERRIDE;
    #endif

    for (size_t i = 0; i < sizeof(qs); ++i) {
        dynamic_keymap_set_qmk_settings(i, p_qs[i]);
    }

    #ifdef DEFAULT_KEYMAP_EECONFIG
        keymap_config.raw = DEFAULT_KEYMAP_EECONFIG;
        eeconfig_update_keymap(keymap_config.raw);
    #endif

    qmk_settings_init();
#endif 

    uint16_t const macro_buffer_size = MIN(sizeof(default_macro_buffer), dynamic_keymap_macro_get_buffer_size());
    dynamic_keymap_macro_set_buffer(0, macro_buffer_size, (uint8_t *)default_macro_buffer);
}

/* GENERATED CODE END */


/* USER CODE BEGIN */
// Modify these values to adjust the scrolling speed
#define SCROLL_DIVISOR_H 8.0
#define SCROLL_DIVISOR_V 8.0

// Variables to store accumulated scroll values
float scroll_accumulated_h = 0;
float scroll_accumulated_v = 0;

bool set_scrolling = false;

// Function to handle mouse reports and perform drag scrolling
report_mouse_t pointing_device_task_user(report_mouse_t mouse_report) {
    if (set_scrolling) {
        // Calculate and accumulate scroll values based on mouse movement and divisors
        scroll_accumulated_h += (float)mouse_report.x / SCROLL_DIVISOR_H;
        scroll_accumulated_v += (float)mouse_report.y / SCROLL_DIVISOR_V;

        // Assign integer parts of accumulated scroll values to the mouse report
        mouse_report.h = (int8_t)scroll_accumulated_h;
        mouse_report.v = (int8_t)scroll_accumulated_v;

        // Update accumulated scroll values by subtracting the integer parts
        scroll_accumulated_h -= (int8_t)scroll_accumulated_h;
        scroll_accumulated_v -= (int8_t)scroll_accumulated_v;

        // Clear the X and Y values of the mouse report
        mouse_report.x = 0;
        mouse_report.y = 0;
    }
#ifdef SCROLL_MODE_INVERT_XY
    // スクロール方向を反転
    mouse_report.h = -mouse_report.h;
    mouse_report.v = -mouse_report.v;
#endif // SCROLL_MODE_INVERT_XY    return mouse_report;
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    if ((keycode == KC_LEFT_ALT) || (keycode == KC_RIGHT_ALT)) {
        set_scrolling = record->event.pressed;
    }
    return true;
}
/* USER CODE END */
